<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Driven AutoCorrect Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Canvas background styling */
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Place it behind all other content */
        }
        /* Ensure main content is layered on top of the canvas */
        .content-container {
            position: relative;
            z-index: 1;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #3b82f6; /* Blue-500 */
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Copy button notification */
        .copy-notification {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .action-button {
            background-color: #2563eb; /* Blue-600 */
            color: white;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 14px 0 rgba(59, 130, 246, 0.39);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .action-button:hover {
             background-color: #1d4ed8; /* Blue-700 */
             transform: scale(1.05);
        }
         .action-button:active {
            transform: scale(0.95);
        }
        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
            background-color: #93c5fd; /* Blue-300 */
        }
        /* Blue aura effect */
        .aura-effect {
             box-shadow: 0 10px 35px -5px rgba(59, 130, 246, 0.35), 0 8px 20px -6px rgba(59, 130, 246, 0.35);
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <canvas id="background-canvas"></canvas>
    <div class="w-full max-w-3xl mx-auto p-4 md:p-8">
        <div class="bg-white rounded-2xl p-6 md:p-10 aura-effect">
            <header class="text-center mb-8">
                <div class="flex justify-center items-center gap-3">
                    <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-600"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
                    <h1 class="text-3xl md:text-4xl font-bold text-gray-800">AI Driven AutoCorrect Tool</h1>
                </div>
                <p class="text-gray-500 mt-2">Correct grammar and spelling in your emails, letters, and documents.</p>
            </header>

            <div class="space-y-6">
                <!-- Input Text Area -->
                <div>
                    <label for="userInput" class="text-lg font-semibold text-gray-700">Let Me Test It ! _ðŸ˜‹</label>
                    <textarea id="userInput" rows="8" class="mt-2 w-full p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-shadow duration-200" placeholder="Paste your email, letter, or any long text here..."></textarea>
                </div>

                <!-- Action Buttons -->
                <div class="flex flex-wrap justify-center items-center gap-4">
                    <button id="correctButton" class="action-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>
                        Correct Grammar
                    </button>
                </div>
            </div>

            <!-- Loading Spinner -->
            <div id="loader" class="hidden flex justify-center items-center my-6">
                <div class="spinner"></div>
            </div>

            <!-- Result Display -->
            <div id="result" class="hidden mt-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 id="resultTitle" class="text-xl font-bold text-gray-800"></h2>
                    <div class="relative">
                        <button id="copyButton" class="flex items-center gap-2 text-sm text-gray-600 bg-gray-200 hover:bg-gray-300 px-3 py-1.5 rounded-md transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                            Copy
                        </button>
                        <span id="copyNotification" class="copy-notification absolute -top-8 right-0 bg-gray-800 text-white text-xs font-bold px-2 py-1 rounded-md opacity-0 transform translate-y-2">Copied!</span>
                    </div>
                </div>
                <!-- Simple text view for the result -->
                <div id="textOutput" class="text-lg p-6 bg-gray-50 border border-gray-200 rounded-lg leading-relaxed whitespace-pre-wrap"></div>
                <!-- Citation Sources -->
                <div id="citations" class="hidden mt-6 border-t pt-4">
                    <h3 class="text-sm font-semibold text-gray-600">Sources:</h3>
                    <div id="citationList" class="text-xs text-gray-500 mt-2 space-y-1"></div>
                </div>
            </div>
            
            <!-- Error Display -->
            <div id="error" class="hidden mt-6 p-4 bg-red-100 border border-red-300 text-red-700 rounded-lg">
                <p id="errorMessage"></p>
            </div>
            <footer class="text-center mt-8">
                <p class="text-sm text-gray-400">Designed by Ar.Â®</p>
            </footer>
        </div>
    </div>

    <script>
        // Notice the API Key is GONE from here!

        const correctButton = document.getElementById('correctButton');
        const copyButton = document.getElementById('copyButton');
        const copyNotification = document.getElementById('copyNotification');
        const userInput = document.getElementById('userInput');
        const textOutput = document.getElementById('textOutput');
        const resultDiv = document.getElementById('result');
        const resultTitle = document.getElementById('resultTitle');
        const loader = document.getElementById('loader');
        const errorDiv = document.getElementById('error');
        const errorMessage = document.getElementById('errorMessage');
        const citationsDiv = document.getElementById('citations');
        const citationList = document.getElementById('citationList');

        let rawResultText = '';

        correctButton.addEventListener('click', handleCorrection);
        copyButton.addEventListener('click', handleCopy);

        async function handleCorrection() {
            const textToProcess = userInput.value.trim();
            if (!textToProcess) {
                showError("Please enter some text to correct.");
                return;
            }

            hideError();
            resultDiv.classList.add('hidden');
            loader.classList.remove('hidden');
            correctButton.disabled = true;

            const systemPrompt = "You are an expert English grammar and spelling checker. Your task is to correct the user's text. Only provide the corrected version of the text in your response. Do not add any extra explanations, apologies, or introductory phrases. Just the corrected text.";

            try {
                // Now we call our own backend, not Google's
                const { text: result, sources } = await callGeminiApi(textToProcess, systemPrompt);
                rawResultText = result;
                resultTitle.textContent = "Corrected Text";
                textOutput.textContent = result;
                resultDiv.classList.remove('hidden');

                if (sources && sources.length > 0) {
                    citationList.innerHTML = sources.map((source, index) => 
                        `<p>${index + 1}. <a href="${source.uri}" target="_blank" rel="noopener noreferrer" class="text-blue-500 hover:underline">${source.title || 'Untitled Source'}</a></p>`
                    ).join('');
                    citationsDiv.classList.remove('hidden');
                } else {
                    citationsDiv.classList.add('hidden');
                }

            } catch (err) {
                console.error('API Call Failed:', err);
                showError(`An error occurred: ${err.message}. Please check the console for more details.`);
            } finally {
                loader.classList.add('hidden');
                correctButton.disabled = false;
            }
        }

        function handleCopy() {
            navigator.clipboard.writeText(rawResultText).then(() => {
                copyNotification.classList.remove('opacity-0', 'translate-y-2');
                copyNotification.classList.add('opacity-100', 'translate-y-0');
                setTimeout(() => {
                    copyNotification.classList.remove('opacity-100', 'translate-y-0');
                    copyNotification.classList.add('opacity-0', 'translate-y-2');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }
        
        async function callGeminiApi(text, systemPrompt) {
            // This now points to our own backend function
            const apiUrl = '/api/correct';

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: text, systemPrompt: systemPrompt })
            });

            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`Request failed: ${errorBody.error || 'Unknown server error'}`);
            }

            // The backend will return the data in the same format
            return await response.json();
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorDiv.classList.remove('hidden');
        }

        function hideError() {
            errorDiv.classList.add('hidden');
        }

        // Canvas Background Logic (No changes needed here)
        (function() {
            const canvas = document.getElementById('background-canvas');
            if (!canvas) return; // Add a check in case canvas doesn't exist
            const ctx = canvas.getContext('2d');

            let width = canvas.width = window.innerWidth;
            let height = canvas.height = window.innerHeight;

            const mouse = { x: null, y: null, radius: 150 };

            window.addEventListener('mousemove', (event) => {
                mouse.x = event.x;
                mouse.y = event.y;
            });
            window.addEventListener('mouseout', () => {
                mouse.x = null;
                mouse.y = null;
            });

            let particles = [];
            const PARTICLE_COUNT = Math.floor((width * height) / 15000);
            const CONNECT_DISTANCE = 140;
            const PARTICLE_COLOR = 'rgba(59, 130, 246, 0.7)';
            const LINE_COLOR_BASE = '150, 180, 255';

            class Particle {
                constructor() {
                    this.x = Math.random() * width;
                    this.y = Math.random() * height;
                    this.vx = (Math.random() - 0.5) * 0.8;
                    this.vy = (Math.random() - 0.5) * 0.8;
                    this.radius = Math.random() * 2 + 1.5;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < this.radius || this.x > width - this.radius) this.vx *= -1;
                    if (this.y < this.radius || this.y > height - this.radius) this.vy *= -1;
                    
                    if (mouse.x && mouse.y) {
                        const dx = mouse.x - this.x;
                        const dy = mouse.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < mouse.radius) {
                            const forceDirectionX = dx / distance;
                            const forceDirectionY = dy / distance;
                            const maxDistance = mouse.radius;
                            const force = (maxDistance - distance) / maxDistance;
                            
                            this.x -= forceDirectionX * force * 2;
                            this.y -= forceDirectionY * force * 2;
                        }
                    }
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = PARTICLE_COLOR;
                    ctx.fill();
                }
            }

            function init() {
                particles = [];
                const currentParticleCount = Math.floor((width * height) / 15000);
                for (let i = 0; i < currentParticleCount; i++) {
                    particles.push(new Particle());
                }
            }

            function connect() {
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < CONNECT_DISTANCE) {
                            const opacity = 1 - (distance / CONNECT_DISTANCE);
                            ctx.strokeStyle = `rgba(${LINE_COLOR_BASE}, ${opacity})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.stroke();
                        }
                    }
                }
            }

            function animate() {
                ctx.clearRect(0, 0, width, height);
                particles.forEach(p => {
                    p.update();
                    p.draw();
                });
                connect();
                requestAnimationFrame(animate);
            }

            window.addEventListener('resize', () => {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                init();
            });

            init();
            animate();
        })();
    </script>
</body>
</html>